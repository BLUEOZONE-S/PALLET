<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structural Crate Optimizer</title>
    
    <!-- Local Libraries -->
    <script src="libs/tailwind.js"></script>
    <script src="libs/react.development.js"></script>
    <script src="libs/react-dom.development.js"></script>
    <script src="libs/babel.min.js"></script>
    <script src="libs/three.min.js"></script>
    <script src="libs/STLLoader.js"></script>
    <script src="libs/lucide.min.js"></script>
    
    <!-- Extra libs from request template -->
    <script src="libs/pdf-lib.min.js"></script>
    <script src="libs/xlsx.full.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sora:wght@300;400;500;600;700;800&display=swap');
        
        :root {
            --primary: #60a5fa;
            --emerald: #7dd3fc;
            --amber: #fbbf24;
            --glass-text: #0f172a;
        }
        body { font-family: 'Sora', sans-serif; }
        
        /* Custom Scrollbar for the list */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        /*
         * Structural Crate Optimizer
         * - Loads item manifests from CSV or demo data.
         * - Expands quantities into individual items and runs a packing algorithm.
         * - Builds pallets with framed wood pockets and optional diagonal bracing.
         * - Enforces max dimensions/weight, optional vertical placement, and safety gaps.
         * - Visualizes the resulting crate with Three.js and renders UI controls with React.
         */

        // --- SHIMS AND POLYFILLS ---

        // 1. React Globals
        const { useState, useEffect, useRef, useCallback } = React;
        
        // 2. Lucide Icon Shim
        // This maps the React component usage <Hammer /> to vanilla lucide icons
        const IconWrapper = ({ name, size = 24, className, ...props }) => {
            const ref = useRef(null);
            useEffect(() => {
                if (window.lucide) {
                    // Lucide vanilla creates SVG inside the element
                    const attrs = { width: size, height: size, class: className, ...props };
                    // Clear previous content
                    if(ref.current) ref.current.innerHTML = '';
                    
                    const iconNode = window.lucide.icons[name];
                    if(iconNode) {
                         const svg = iconNode.toSvg(attrs);
                         ref.current.innerHTML = svg;
                    }
                }
            }, [name, size, className]);

            return <span ref={ref} style={{display: 'inline-flex', alignItems: 'center'}} />;
        };

        // Define icons used in the code
        const Upload = (p) => <IconWrapper name="upload" {...p} />;
        const Play = (p) => <IconWrapper name="play" {...p} />;
        const Info = (p) => <IconWrapper name="info" {...p} />;
        const X = (p) => <IconWrapper name="x" {...p} />;
        const Zap = (p) => <IconWrapper name="zap" {...p} />;
        const Box = (p) => <IconWrapper name="box" {...p} />;
        const ArrowUp = (p) => <IconWrapper name="arrow-up" {...p} />;
        const ShieldAlert = (p) => <IconWrapper name="shield-alert" {...p} />;
        const Scale = (p) => <IconWrapper name="scale" {...p} />;
        const Hammer = (p) => <IconWrapper name="hammer" {...p} />;
        const Settings = (p) => <IconWrapper name="settings" {...p} />;
        const RefreshCw = (p) => <IconWrapper name="refresh-cw" {...p} />;

        // --- APP CODE ---
        
        



const PalletOptimizer = () => {
  // React state: items, computed pallets, and UI status
  const [items, setItems] = useState([]);
  const [pallets, setPallets] = useState([]);
  const [errors, setErrors] = useState([]);
  const [currentPalletView, setCurrentPalletView] = useState(0);
  const [lastRunConfig, setLastRunConfig] = useState(null);
  const [isConfigDirty, setIsConfigDirty] = useState(false);
  const [stlFiles, setStlFiles] = useState({});
  const [loadedMeshes, setLoadedMeshes] = useState({});
  const [voxelCache, setVoxelCache] = useState({});
  const [palletVoxelGrid, setPalletVoxelGrid] = useState([]);
  const [stlUnits, setStlUnits] = useState('in');
  const [stlLoadStatus, setStlLoadStatus] = useState({ loaded: 0, total: 0, missing: [] });
  const [bomItems, setBomItems] = useState([]);
  const [renderStlMeshes, setRenderStlMeshes] = useState(false);
  const [renderProxyBoxes, setRenderProxyBoxes] = useState(true);
  const [useStlForCollisions, setUseStlForCollisions] = useState(false);
  const [showPlacementBoxes, setShowPlacementBoxes] = useState(true);
  const [showVoxelDebug, setShowVoxelDebug] = useState(false);
  const [showStlBounds, setShowStlBounds] = useState(true);
  const [showDeadzoneBox, setShowDeadzoneBox] = useState(true);
  const [normalizeStlToBOM, setNormalizeStlToBOM] = useState(false);
  const [debugLogs, setDebugLogs] = useState([]);
  const [sidebarTab, setSidebarTab] = useState('controls');
  const stlFilesAvailable = Object.keys(stlFiles).length > 0;
  const debugLogLimit = 200;
  const lastMissingKeyRef = useRef('');
  const stlLoadAttemptsRef = useRef(new Map());
  const lastAutoRunRef = useRef('');
  
  // User-controlled configuration for pallet constraints and framing
  const [config, setConfig] = useState({
    palletLength: 250, // Max length 20'10"
    palletWidth: 84,   // Max width 7'
    maxHeight: 80,     // Safe height buffer
    maxWeight: 2500,   // Max lbs per pallet
    safetyGap: 1.0,    // Gap from edges
    framingSpacing: 48, // Vertical posts every 48"
    lumberWidth: 3.5,   // 2x4 width (actual)
    lumberThick: 1.5,   // 2x4 thickness (actual)
    addBracing: true,   // Add diagonal bracing
    allowVertical: true // Allow items to stand if they fit
  });

  // Three.js mounts and references
  const mountRef = useRef(null);
  const sceneRef = useRef(null);
  const rendererRef = useRef(null);

  // Consistent colors for items in the scene
  const colorPalette = [
    0x3B82F6, 0xEF4444, 0x10B981, 0xF59E0B, 0x8B5CF6, 0xEC4899,
    0x6366F1, 0x14B8A6, 0xF97316, 0x84CC16, 0x06B6D4, 0xD946EF
  ];
  const voxelSize = 0.25;
  const shouldUseStlGeometry = useStlForCollisions || renderStlMeshes || showVoxelDebug || normalizeStlToBOM;

  // -------------------------------------------------------------------------
  // 1. DATA PARSING
  // -------------------------------------------------------------------------
  const hasValidDims = (dims) => (
    Number.isFinite(dims.x) &&
    Number.isFinite(dims.y) &&
    Number.isFinite(dims.z) &&
    dims.x > 0 &&
    dims.y > 0 &&
    dims.z > 0
  );

  const getCsvDims = (item) => ({ x: item.width, y: item.height, z: item.length });
  const hasValidCsvDims = (item) => hasValidDims(getCsvDims(item));

  const shouldLoadStlForItem = (item) => !hasValidCsvDims(item) || shouldUseStlGeometry;
  // Load demo items to show the optimizer quickly
  const loadDemoData = () => {
    const demoItems = [
      { itemNumber: 'PIPE-240-HVY', height: 4.5, width: 4.5, length: 240, weight: 180, qty: 4 },
      { itemNumber: 'PIPE-120-STD', height: 4, width: 4, length: 120, weight: 80, qty: 6 },
      { itemNumber: 'SHORT-POST-60', height: 4, width: 4, length: 60, weight: 45, qty: 15 }, // Should stand vertically if logic permits
      { itemNumber: 'CURVED-96', height: 8, width: 12, length: 96, weight: 65, qty: 2 }, 
    ];
    processItems(demoItems);
  };

  // Parse CSV uploads and convert into item objects
  const parseBOM = (text) => {
    const lines = text.split(/\r?\n/).filter(line => line.trim().length > 0);
    if (lines.length === 0) throw new Error('Empty CSV.');
    const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
    const required = ['number', 'weight', 'qty'];
    const headerMap = {};
    headers.forEach((h, idx) => { headerMap[h] = idx; });
    const missingHeaders = required.filter(key => headerMap[key] === undefined);
    if (missingHeaders.length > 0) {
      throw new Error(`Missing headers: ${missingHeaders.join(', ')}`);
    }

    const parsedItems = [];
    for (let i = 1; i < lines.length; i++) {
      const row = lines[i].split(',').map(cell => cell.trim());
      const itemNumber = row[headerMap.number];
      if (!itemNumber) continue;
      const item = {
        itemNumber,
        height: headerMap.h !== undefined ? parseFloat(row[headerMap.h]) : NaN,
        width: headerMap.w !== undefined ? parseFloat(row[headerMap.w]) : NaN,
        length: headerMap.l !== undefined ? parseFloat(row[headerMap.l]) : NaN,
        weight: parseFloat(row[headerMap.weight]),
        qty: parseFloat(row[headerMap.qty]) || 1
      };
      if (!isNaN(item.weight)) parsedItems.push(item);
    }
    return parsedItems;
  };

  const addDebugLog = useCallback((message, level = 'info') => {
    setDebugLogs(prev => {
      const entry = {
        id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
        message,
        level,
        timestamp: new Date().toLocaleTimeString()
      };
      const next = [...prev, entry];
      if (next.length > debugLogLimit) {
        return next.slice(next.length - debugLogLimit);
      }
      return next;
    });
  }, []);

  const reportErrors = (messages) => {
    setErrors(messages);
    messages.forEach(message => addDebugLog(message, 'error'));
  };

  const handleFileUpload = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const text = event.target.result;
        const parsedItems = parseBOM(text);
        processItems(parsedItems);
      } catch (err) {
        const message = err.message || 'Failed to parse CSV.';
        reportErrors([message]);
      }
    };
    reader.readAsText(file);
  };

  // Expand each row by quantity and reset results
  const processItems = (rawItems) => {
    const nextBomItems = rawItems.map(item => {
      const stlKey = item.itemNumber.trim().toLowerCase();
      const stlFound = Boolean(stlFiles[stlKey]);
      return { ...item, stlKey, stlFound };
    });
    const expanded = [];
    nextBomItems.forEach((item, idx) => {
      for (let i = 0; i < item.qty; i++) {
        expanded.push({
          ...item,
          uniqueId: `${item.itemNumber}-${i}`,
          colorIndex: idx % colorPalette.length
        });
      }
    });
    setBomItems(nextBomItems);
    setItems(expanded);
    setPallets([]);
    setErrors([]);
    addDebugLog(`Loaded ${rawItems.length} BOM rows.`, 'info');
  };

  // -------------------------------------------------------------------------
  // 1B. STL + VOXEL HANDLING
  // -------------------------------------------------------------------------
  const loadSTLFolder = (e) => {
    const files = Array.from(e.target.files || []);
    const nextMap = {};
    files.forEach((file) => {
      if (!file.name.toLowerCase().endsWith('.stl')) return;
      const baseName = file.name.replace(/\.stl$/i, '').trim().toLowerCase();
      if (baseName) nextMap[baseName] = file;
    });
    stlLoadAttemptsRef.current.clear();
    setLoadedMeshes(prev => {
      const next = { ...prev };
      Object.keys(nextMap).forEach(key => {
        delete next[key];
      });
      return next;
    });
    setVoxelCache(prev => {
      const updated = { ...prev };
      Object.keys(nextMap).forEach(key => {
        delete updated[`stl:${key}`];
      });
      return updated;
    });
    setStlFiles(prev => ({ ...prev, ...nextMap }));
    addDebugLog(`STL folder selected. ${Object.keys(nextMap).length} STL file(s) indexed.`, 'info');
  };

  const createVoxelGrid = (nx, ny, nz, voxelSize, data) => {
    const filled = data || new Uint8Array(nx * ny * nz);
    const occupied = [];
    for (let i = 0; i < filled.length; i++) {
      if (filled[i]) occupied.push(i);
    }
    return { nx, ny, nz, voxelSize, data: filled, occupied };
  };

  const voxelizeBox = (dims, voxelSize) => {
    const nx = Math.max(1, Math.ceil(dims.x / voxelSize));
    const ny = Math.max(1, Math.ceil(dims.y / voxelSize));
    const nz = Math.max(1, Math.ceil(dims.z / voxelSize));
    const data = new Uint8Array(nx * ny * nz);
    data.fill(1);
    return createVoxelGrid(nx, ny, nz, voxelSize, data);
  };

  const triBoxOverlap = (boxcenter, boxhalfsize, triverts) => {
    const v0 = [
      triverts[0][0] - boxcenter[0],
      triverts[0][1] - boxcenter[1],
      triverts[0][2] - boxcenter[2]
    ];
    const v1 = [
      triverts[1][0] - boxcenter[0],
      triverts[1][1] - boxcenter[1],
      triverts[1][2] - boxcenter[2]
    ];
    const v2 = [
      triverts[2][0] - boxcenter[0],
      triverts[2][1] - boxcenter[1],
      triverts[2][2] - boxcenter[2]
    ];

    const e0 = [v1[0] - v0[0], v1[1] - v0[1], v1[2] - v0[2]];
    const e1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
    const e2 = [v0[0] - v2[0], v0[1] - v2[1], v0[2] - v2[2]];

    const fex = Math.abs(e0[0]);
    const fey = Math.abs(e0[1]);
    const fez = Math.abs(e0[2]);

    const axisTest = (a, b, fa, fb, v0, v1, v2, half) => {
      const p0 = a * v0[1] - b * v0[2];
      const p1 = a * v1[1] - b * v1[2];
      const p2 = a * v2[1] - b * v2[2];
      const min = Math.min(p0, p1, p2);
      const max = Math.max(p0, p1, p2);
      const rad = fa * half[1] + fb * half[2];
      return !(min > rad || max < -rad);
    };

    if (!axisTest(e0[2], e0[1], fez, fey, v0, v1, v2, boxhalfsize)) return false;
    if (!axisTest(e0[2], e0[0], fez, fex, v0, v1, v2, boxhalfsize)) return false;
    if (!axisTest(e0[1], e0[0], fey, fex, v0, v1, v2, boxhalfsize)) return false;

    const fex1 = Math.abs(e1[0]);
    const fey1 = Math.abs(e1[1]);
    const fez1 = Math.abs(e1[2]);
    if (!axisTest(e1[2], e1[1], fez1, fey1, v0, v1, v2, boxhalfsize)) return false;
    if (!axisTest(e1[2], e1[0], fez1, fex1, v0, v1, v2, boxhalfsize)) return false;
    if (!axisTest(e1[1], e1[0], fey1, fex1, v0, v1, v2, boxhalfsize)) return false;

    const fex2 = Math.abs(e2[0]);
    const fey2 = Math.abs(e2[1]);
    const fez2 = Math.abs(e2[2]);
    if (!axisTest(e2[2], e2[1], fez2, fey2, v0, v1, v2, boxhalfsize)) return false;
    if (!axisTest(e2[2], e2[0], fez2, fex2, v0, v1, v2, boxhalfsize)) return false;
    if (!axisTest(e2[1], e2[0], fey2, fex2, v0, v1, v2, boxhalfsize)) return false;

    const minX = Math.min(v0[0], v1[0], v2[0]);
    const maxX = Math.max(v0[0], v1[0], v2[0]);
    if (minX > boxhalfsize[0] || maxX < -boxhalfsize[0]) return false;
    const minY = Math.min(v0[1], v1[1], v2[1]);
    const maxY = Math.max(v0[1], v1[1], v2[1]);
    if (minY > boxhalfsize[1] || maxY < -boxhalfsize[1]) return false;
    const minZ = Math.min(v0[2], v1[2], v2[2]);
    const maxZ = Math.max(v0[2], v1[2], v2[2]);
    if (minZ > boxhalfsize[2] || maxZ < -boxhalfsize[2]) return false;

    const normal = [
      e0[1] * e1[2] - e0[2] * e1[1],
      e0[2] * e1[0] - e0[0] * e1[2],
      e0[0] * e1[1] - e0[1] * e1[0]
    ];

    const d = -(normal[0] * v0[0] + normal[1] * v0[1] + normal[2] * v0[2]);
    const r = boxhalfsize[0] * Math.abs(normal[0]) +
      boxhalfsize[1] * Math.abs(normal[1]) +
      boxhalfsize[2] * Math.abs(normal[2]);
    const s = normal[0] * boxcenter[0] + normal[1] * boxcenter[1] + normal[2] * boxcenter[2] + d;
    return Math.abs(s) <= r;
  };

  const voxelizeMesh = (geometry, voxelSize) => {
    const geo = geometry.clone();
    geo.computeBoundingBox();
    const bbox = geo.boundingBox;
    const size = new THREE.Vector3();
    bbox.getSize(size);
    const nx = Math.max(1, Math.ceil(size.x / voxelSize));
    const ny = Math.max(1, Math.ceil(size.y / voxelSize));
    const nz = Math.max(1, Math.ceil(size.z / voxelSize));
    const data = new Uint8Array(nx * ny * nz);
    const pos = geo.attributes.position.array;
    const min = bbox.min;

    for (let i = 0; i < pos.length; i += 9) {
      const v0 = [pos[i] - min.x, pos[i + 1] - min.y, pos[i + 2] - min.z];
      const v1 = [pos[i + 3] - min.x, pos[i + 4] - min.y, pos[i + 5] - min.z];
      const v2 = [pos[i + 6] - min.x, pos[i + 7] - min.y, pos[i + 8] - min.z];
      const triMin = [
        Math.min(v0[0], v1[0], v2[0]),
        Math.min(v0[1], v1[1], v2[1]),
        Math.min(v0[2], v1[2], v2[2])
      ];
      const triMax = [
        Math.max(v0[0], v1[0], v2[0]),
        Math.max(v0[1], v1[1], v2[1]),
        Math.max(v0[2], v1[2], v2[2])
      ];
      const minX = Math.max(0, Math.floor(triMin[0] / voxelSize));
      const minY = Math.max(0, Math.floor(triMin[1] / voxelSize));
      const minZ = Math.max(0, Math.floor(triMin[2] / voxelSize));
      const maxX = Math.min(nx - 1, Math.floor(triMax[0] / voxelSize));
      const maxY = Math.min(ny - 1, Math.floor(triMax[1] / voxelSize));
      const maxZ = Math.min(nz - 1, Math.floor(triMax[2] / voxelSize));
      for (let x = minX; x <= maxX; x++) {
        for (let y = minY; y <= maxY; y++) {
          for (let z = minZ; z <= maxZ; z++) {
            const center = [
              (x + 0.5) * voxelSize,
              (y + 0.5) * voxelSize,
              (z + 0.5) * voxelSize
            ];
            const half = [voxelSize / 2, voxelSize / 2, voxelSize / 2];
            if (triBoxOverlap(center, half, [v0, v1, v2])) {
              const idx = x + nx * (y + ny * z);
              data[idx] = 1;
            }
          }
        }
      }
    }

    const dilated = data.slice();
    const neighborOffsets = [-1, 0, 1];
    for (let x = 0; x < nx; x++) {
      for (let y = 0; y < ny; y++) {
        for (let z = 0; z < nz; z++) {
          const idx = x + nx * (y + ny * z);
          if (!data[idx]) continue;
          neighborOffsets.forEach(dx => {
            neighborOffsets.forEach(dy => {
              neighborOffsets.forEach(dz => {
                const nxp = x + dx;
                const nyp = y + dy;
                const nzp = z + dz;
                if (nxp < 0 || nyp < 0 || nzp < 0 || nxp >= nx || nyp >= ny || nzp >= nz) return;
                const nIdx = nxp + nx * (nyp + ny * nzp);
                dilated[nIdx] = 1;
              });
            });
          });
        }
      }
    }

    return createVoxelGrid(nx, ny, nz, voxelSize, dilated);
  };

  const rotateVoxelGridY = (grid, rotation) => {
    const rot = ((rotation % 360) + 360) % 360;
    if (rot === 0) return grid;
    const { nx, ny, nz, voxelSize, data } = grid;
    let outNx = nx;
    let outNz = nz;
    if (rot === 90 || rot === 270) {
      outNx = nz;
      outNz = nx;
    }
    const outData = new Uint8Array(outNx * ny * outNz);
    for (let x = 0; x < nx; x++) {
      for (let y = 0; y < ny; y++) {
        for (let z = 0; z < nz; z++) {
          const idx = x + nx * (y + ny * z);
          if (!data[idx]) continue;
          let rx = x;
          let rz = z;
          if (rot === 90) {
            rx = nz - 1 - z;
            rz = x;
          } else if (rot === 180) {
            rx = nx - 1 - x;
            rz = nz - 1 - z;
          } else if (rot === 270) {
            rx = z;
            rz = nx - 1 - x;
          }
          const outIdx = rx + outNx * (y + ny * rz);
          outData[outIdx] = 1;
        }
      }
    }
    return createVoxelGrid(outNx, ny, outNz, voxelSize, outData);
  };

  const rotateVoxelGridVertical = (grid) => {
    const { nx, ny, nz, voxelSize, data } = grid;
    const outData = new Uint8Array(nx * nz * ny);
    for (let x = 0; x < nx; x++) {
      for (let y = 0; y < ny; y++) {
        for (let z = 0; z < nz; z++) {
          const idx = x + nx * (y + ny * z);
          if (!data[idx]) continue;
          const ry = z;
          const rz = ny - 1 - y;
          const outIdx = x + nx * (ry + nz * rz);
          outData[outIdx] = 1;
        }
      }
    }
    return createVoxelGrid(nx, nz, ny, voxelSize, outData);
  };

  const rotateVoxelGrid = (grid, rotation, vertical) => {
    let rotated = grid;
    if (vertical) {
      rotated = rotateVoxelGridVertical(rotated);
    }
    return rotateVoxelGridY(rotated, rotation);
  };

  const testVoxelFit = (grid, worldGrid, pos, dims) => {
    const baseX = Math.floor((pos.x - dims.x / 2) / voxelSize);
    const baseY = Math.floor((pos.y - dims.y / 2) / voxelSize);
    const baseZ = Math.floor((pos.z - dims.z / 2) / voxelSize);
    const { nx, ny, nz, data } = grid;
    const { nx: wNx, ny: wNy, nz: wNz, data: wData } = worldGrid;
    for (let i = 0; i < grid.occupied.length; i++) {
      const idx = grid.occupied[i];
      const z = Math.floor(idx / (nx * ny));
      const y = Math.floor((idx - z * nx * ny) / nx);
      const x = idx - z * nx * ny - y * nx;
      const wx = baseX + x;
      const wy = baseY + y;
      const wz = baseZ + z;
      if (wx < 0 || wy < 0 || wz < 0 || wx >= wNx || wy >= wNy || wz >= wNz) {
        return false;
      }
      const wIdx = wx + wNx * (wy + wNy * wz);
      if (wData[wIdx]) return false;
    }
    return true;
  };

  const stampVoxels = (grid, worldGrid, pos, dims) => {
    const baseX = Math.floor((pos.x - dims.x / 2) / voxelSize);
    const baseY = Math.floor((pos.y - dims.y / 2) / voxelSize);
    const baseZ = Math.floor((pos.z - dims.z / 2) / voxelSize);
    const { nx, ny, nz } = grid;
    const { nx: wNx, ny: wNy, data: wData } = worldGrid;
    for (let i = 0; i < grid.occupied.length; i++) {
      const idx = grid.occupied[i];
      const z = Math.floor(idx / (nx * ny));
      const y = Math.floor((idx - z * nx * ny) / nx);
      const x = idx - z * nx * ny - y * nx;
      const wx = baseX + x;
      const wy = baseY + y;
      const wz = baseZ + z;
      if (wx < 0 || wy < 0 || wz < 0 || wx >= wNx || wy >= wNy || wz >= worldGrid.nz) continue;
      const wIdx = wx + wNx * (wy + wNy * wz);
      wData[wIdx] = 1;
    }
  };

  const getItemDims = (item) => {
    const stl = loadedMeshes[item.stlKey];
    const csvDims = getCsvDims(item);
    if (normalizeStlToBOM && hasValidDims(csvDims)) {
      return csvDims;
    }
    if (stl && stl.dims && shouldUseStlGeometry && !normalizeStlToBOM) {
      return { x: stl.dims.x, y: stl.dims.y, z: stl.dims.z };
    }
    return csvDims;
  };

  const getItemVoxelGrid = (item, rotation, vertical) => {
    const stl = loadedMeshes[item.stlKey];
    if (stl && stl.voxelGrid && !normalizeStlToBOM && (useStlForCollisions || showVoxelDebug)) {
      return rotateVoxelGrid(stl.voxelGrid, rotation, vertical);
    }
    const dims = getItemDims(item);
    const key = `box:${dims.x}x${dims.y}x${dims.z}`;
    const baseGrid = voxelCache[key] || voxelizeBox(dims, voxelSize);
    if (!voxelCache[key]) {
      setVoxelCache(prev => ({ ...prev, [key]: baseGrid }));
    }
    return rotateVoxelGrid(baseGrid, rotation, vertical);
  };

  const createPalletVoxelGrid = () => {
    const nx = Math.max(1, Math.ceil(config.palletWidth / voxelSize));
    const ny = Math.max(1, Math.ceil(config.maxHeight / voxelSize));
    const nz = Math.max(1, Math.ceil(config.palletLength / voxelSize));
    return createVoxelGrid(nx, ny, nz, voxelSize);
  };

  const autoOrientGeometry = (geometry) => {
    geometry.computeBoundingBox();
    const size = new THREE.Vector3();
    geometry.boundingBox.getSize(size);
    const dims = { x: size.x, y: size.y, z: size.z };
    const largestAxis = Object.entries(dims).sort((a, b) => b[1] - a[1])[0][0];
    let applied = [];
    if (largestAxis === 'x') {
      geometry.rotateY(Math.PI / 2);
      applied.push('rotateY(90°)');
    } else if (largestAxis === 'y') {
      geometry.rotateX(-Math.PI / 2);
      applied.push('rotateX(-90°)');
    }
    geometry.computeBoundingBox();
    geometry.boundingBox.getSize(size);
    if (size.x < size.y) {
      geometry.rotateZ(Math.PI / 2);
      applied.push('rotateZ(90°)');
    }
    return applied;
  };

  const loadStlFile = async (file, stlKey, shouldVoxelize) => {
    let payload;
    try {
      payload = await file.arrayBuffer();
    } catch (err) {
      try {
        payload = await file.text();
      } catch (textErr) {
        throw new Error(`Failed to read STL file "${file.name}".`);
      }
    }
    if (payload instanceof ArrayBuffer && payload.byteLength === 0) {
      throw new Error(`STL file "${file.name}" is empty.`);
    }
    const loader = new THREE.STLLoader();
    const geometry = loader.parse(payload);
    const scale = stlUnits === 'mm' ? 1 / 25.4 : 1;
    geometry.scale(scale, scale, scale);
    const applied = autoOrientGeometry(geometry);
    geometry.computeBoundingBox();
    const bbox = geometry.boundingBox;
    const center = new THREE.Vector3();
    bbox.getCenter(center);
    geometry.translate(-center.x, -center.y, -center.z);
    geometry.computeBoundingBox();
    const centeredBox = geometry.boundingBox;
    const dims = {
      x: centeredBox.max.x - centeredBox.min.x,
      y: centeredBox.max.y - centeredBox.min.y,
      z: centeredBox.max.z - centeredBox.min.z
    };
    const voxelGrid = shouldVoxelize ? voxelizeMesh(geometry, voxelSize) : null;
    if (applied.length > 0) {
      addDebugLog(`Auto-oriented STL "${stlKey}" with ${applied.join(', ')}.`, 'info');
    }
    return { stlKey, geometry, dims, voxelGrid };
  };

  useEffect(() => {
    setLoadedMeshes({});
    setVoxelCache({});
    stlLoadAttemptsRef.current.clear();
  }, [stlUnits]);

  useEffect(() => {
    const attempts = stlLoadAttemptsRef.current;
    Object.entries(stlFiles).forEach(([key, file]) => {
      const signature = `${file.name}:${file.size}:${file.lastModified}`;
      const existing = attempts.get(key);
      if (existing && existing.signature !== signature) {
        attempts.delete(key);
      }
    });
    Array.from(attempts.keys()).forEach(key => {
      if (!stlFiles[key]) {
        attempts.delete(key);
      }
    });
  }, [stlFiles]);

  useEffect(() => {
    if (bomItems.length === 0) {
      setStlLoadStatus({ loaded: 0, total: 0, missing: [] });
      return;
    }
    const requiredKeys = Array.from(
      new Set(bomItems.filter(shouldLoadStlForItem).map(item => item.stlKey))
    );
    const hasStlFiles = Object.keys(stlFiles).length > 0;

    setLoadedMeshes(prev => {
      const pruned = {};
      requiredKeys.forEach(key => {
        if (prev[key]) pruned[key] = prev[key];
      });
      return pruned;
    });
    setVoxelCache(prev => {
      const updated = { ...prev };
      Object.keys(updated).forEach(key => {
        if (key.startsWith('stl:')) {
          const stlKey = key.slice(4);
          if (!requiredKeys.includes(stlKey)) {
            delete updated[key];
          }
        }
      });
      return updated;
    });

    if (!hasStlFiles || requiredKeys.length === 0) {
      setStlLoadStatus({ loaded: 0, total: 0, missing: [] });
      return;
    }
    let isCancelled = false;
    const missing = requiredKeys.filter(key => !stlFiles[key]);
    const failedKeys = requiredKeys.filter(key => {
      const file = stlFiles[key];
      const attempt = stlLoadAttemptsRef.current.get(key);
      if (!file || !attempt) return false;
      const signature = `${file.name}:${file.size}:${file.lastModified}`;
      return attempt.status === 'failed' && attempt.signature === signature;
    });
    const missingList = Array.from(new Set([...missing, ...failedKeys]));
    setStlLoadStatus({ loaded: 0, total: requiredKeys.length, missing: missingList });

    const loadAll = async () => {
      let loadedCount = 0;
      const nextLoaded = {};
      for (const key of requiredKeys) {
        const file = stlFiles[key];
        if (!file) continue;
        if (loadedMeshes[key]) {
          loadedCount += 1;
          continue;
        }
        const signature = `${file.name}:${file.size}:${file.lastModified}`;
        const attempt = stlLoadAttemptsRef.current.get(key);
        if (attempt && attempt.signature === signature) {
          if (attempt.status === 'failed' || attempt.status === 'pending') {
            continue;
          }
        }
        stlLoadAttemptsRef.current.set(key, { status: 'pending', signature });
        try {
          const result = await loadStlFile(file, key, useStlForCollisions || showVoxelDebug);
          nextLoaded[key] = result;
          loadedCount += 1;
          stlLoadAttemptsRef.current.set(key, { status: 'loaded', signature });
          if (!isCancelled) {
            setStlLoadStatus(prev => ({ ...prev, loaded: loadedCount }));
          }
          if (!isCancelled) {
            addDebugLog(
              `Loaded STL "${key}" (${result.dims.x.toFixed(2)} x ${result.dims.y.toFixed(2)} x ${result.dims.z.toFixed(2)} in).`,
              'info'
            );
          }
        } catch (err) {
          missingList.push(key);
          stlLoadAttemptsRef.current.set(key, { status: 'failed', signature });
          if (!isCancelled) {
            setStlLoadStatus(prev => ({ ...prev, missing: Array.from(new Set(missingList)) }));
          }
          if (!isCancelled) {
            addDebugLog(`Failed to load STL "${key}": ${err.message || err}`, 'error');
          }
        }
      }
      if (!isCancelled && Object.keys(nextLoaded).length > 0) {
        setLoadedMeshes(prev => ({ ...prev, ...nextLoaded }));
        setVoxelCache(prev => {
          const updated = { ...prev };
          Object.entries(nextLoaded).forEach(([key, data]) => {
            updated[`stl:${key}`] = data.voxelGrid;
          });
          return updated;
        });
      }
    };
    loadAll();
    return () => { isCancelled = true; };
  }, [
    bomItems,
    stlFiles,
    stlUnits,
    loadedMeshes,
    renderStlMeshes,
    showVoxelDebug,
    useStlForCollisions,
    normalizeStlToBOM,
    addDebugLog
  ]);

  useEffect(() => {
    if (bomItems.length === 0) return;
    setBomItems(prev => prev.map(item => ({
      ...item,
      stlFound: Boolean(stlFiles[item.stlKey])
    })));
  }, [stlFiles]);

  useEffect(() => {
    if (normalizeStlToBOM && Object.keys(loadedMeshes).length > 0) {
      setNormalizeStlToBOM(false);
      addDebugLog('CSV dimension override disabled because STL geometry is available.', 'warn');
    }
  }, [normalizeStlToBOM, loadedMeshes, addDebugLog]);

  useEffect(() => {
    const missingKey = stlLoadStatus.missing.join('|');
    if (missingKey === lastMissingKeyRef.current) return;
    lastMissingKeyRef.current = missingKey;
    if (stlLoadStatus.missing.length > 0) {
      addDebugLog(`Missing STL(s): ${stlLoadStatus.missing.join(', ')}`, 'warn');
    } else if (stlLoadStatus.total > 0 && stlLoadStatus.loaded === stlLoadStatus.total) {
      addDebugLog('All required STL files loaded.', 'info');
    }
  }, [stlLoadStatus, addDebugLog]);

  useEffect(() => {
    if (items.length === 0) return;
    const requiredKeys = Array.from(
      new Set(bomItems.filter(item => !hasValidCsvDims(item)).map(item => item.stlKey))
    );
    const stlReady = requiredKeys.length === 0 || requiredKeys.every(key => loadedMeshes[key]);
    if (!stlReady) return;
    if (isConfigDirty && lastRunConfig !== null) return;
    const autoKey = [
      items.length,
      bomItems.length,
      Object.keys(loadedMeshes).length,
      stlLoadStatus.loaded,
      stlLoadStatus.total
    ].join('|');
    if (autoKey === lastAutoRunRef.current) return;
    lastAutoRunRef.current = autoKey;
    runOptimization();
  }, [
    items,
    bomItems,
    loadedMeshes,
    stlLoadStatus.loaded,
    stlLoadStatus.total,
    isConfigDirty,
    lastRunConfig
  ]);

  // -------------------------------------------------------------------------
  // 2. FRAMING GENERATOR (The Wood Structure)
  // -------------------------------------------------------------------------

  // Helper to create a single wood piece with dims and position
  const createLumber = (type, dimX, dimY, dimZ, posX, posY, posZ) => ({
      type,
      dims: { x: dimX, y: dimY, z: dimZ },
      pos: { x: posX, y: posY, z: posZ }
  });

  const toFrameKey = (frame) => {
    const round = (value) => Number(value).toFixed(3);
    if (frame.isDiagonal) {
      return [
        'diag',
        round(frame.start.x),
        round(frame.start.y),
        round(frame.start.z),
        round(frame.end.x),
        round(frame.end.y),
        round(frame.end.z),
        round(frame.dims.x),
        round(frame.dims.y)
      ].join('|');
    }

    return [
      frame.type,
      round(frame.pos.x),
      round(frame.pos.y),
      round(frame.pos.z),
      round(frame.dims.x),
      round(frame.dims.y),
      round(frame.dims.z)
    ].join('|');
  };

  const addWoodFrame = (pallet, frame, registry) => {
    const key = toFrameKey(frame);
    if (registry.has(key)) return;
    registry.add(key);
    pallet.woodFrames.push(frame);
  };

  // -------------------------------------------------------------------------
  // 3. OPTIMIZATION ALGORITHM
  // -------------------------------------------------------------------------

  // Calculate the preferred orientation for sorting/stacking decisions
  const getPreferredOrientation = (item) => {
    const baseDims = getItemDims(item);
    let dims = { x: baseDims.x, y: baseDims.y, z: baseDims.z };
    let vertical = false;

    if (config.allowVertical && dims.z < config.maxHeight && dims.z < 90) {
      dims = { x: baseDims.x, y: baseDims.z, z: baseDims.y };
      vertical = true;
    } else if (baseDims.x > baseDims.y) {
      dims = { x: baseDims.y, y: baseDims.x, z: baseDims.z };
    }

    return { dims, vertical };
  };

  const computeDeadzoneBox = (pallet) => {
    if (!pallet.items.length) return null;
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    let minZ = Infinity;
    let maxZ = -Infinity;
    pallet.items.forEach(item => {
      const dims = item.finalDims;
      minX = Math.min(minX, item.position.x - dims.x / 2);
      maxX = Math.max(maxX, item.position.x + dims.x / 2);
      minY = Math.min(minY, item.position.y - dims.y / 2);
      maxY = Math.max(maxY, item.position.y + dims.y / 2);
      minZ = Math.min(minZ, item.position.z - dims.z / 2);
      maxZ = Math.max(maxZ, item.position.z + dims.z / 2);
    });

    const bounds = {
      minX: config.safetyGap,
      maxX: config.palletWidth - config.safetyGap,
      minY: 0,
      maxY: config.maxHeight,
      minZ: config.safetyGap,
      maxZ: config.palletLength - config.safetyGap
    };

    const candidates = [];
    const addCandidate = (label, cminX, cmaxX, cminY, cmaxY, cminZ, cmaxZ) => {
      const dims = {
        x: Math.max(0, cmaxX - cminX),
        y: Math.max(0, cmaxY - cminY),
        z: Math.max(0, cmaxZ - cminZ)
      };
      if (dims.x <= 0 || dims.y <= 0 || dims.z <= 0) return;
      candidates.push({
        label,
        dims,
        pos: {
          x: cminX + dims.x / 2,
          y: cminY + dims.y / 2,
          z: cminZ + dims.z / 2
        },
        volume: dims.x * dims.y * dims.z
      });
    };

    addCandidate('left', bounds.minX, Math.min(minX, bounds.maxX), bounds.minY, bounds.maxY, bounds.minZ, bounds.maxZ);
    addCandidate('right', Math.max(maxX, bounds.minX), bounds.maxX, bounds.minY, bounds.maxY, bounds.minZ, bounds.maxZ);
    addCandidate('front', bounds.minX, bounds.maxX, bounds.minY, bounds.maxY, bounds.minZ, Math.min(minZ, bounds.maxZ));
    addCandidate('back', bounds.minX, bounds.maxX, bounds.minY, bounds.maxY, Math.max(maxZ, bounds.minZ), bounds.maxZ);
    addCandidate('top', bounds.minX, bounds.maxX, Math.max(maxY, bounds.minY), bounds.maxY, bounds.minZ, bounds.maxZ);

    if (candidates.length === 0) return null;
    candidates.sort((a, b) => b.volume - a.volume);
    return candidates[0];
  };

  // Run the crate build and placement algorithm
  const runOptimization = () => {
    if (items.length === 0) return;
    setLastRunConfig({ ...config });
    setIsConfigDirty(false);
    
    const workingItems = items.map((item) => ({ ...item, isPlaced: false }));
    const invalidItems = workingItems.filter(item => !hasValidDims(getItemDims(item)));
    if (invalidItems.length > 0) {
      reportErrors([
        `Missing dimensions for ${invalidItems.map(item => item.itemNumber).join(', ')}. Add CSV dims or provide STL files.`
      ]);
      return;
    }

    // Sort: Longer horizontal parts first (bottom layers), then heavier items
    const sortedQueue = [...workingItems].sort((a, b) => {
      const aOrientation = getPreferredOrientation(a);
      const bOrientation = getPreferredOrientation(b);
      const aLength = aOrientation.vertical ? 0 : aOrientation.dims.z;
      const bLength = bOrientation.vertical ? 0 : bOrientation.dims.z;
      if (aLength !== bLength) return bLength - aLength;
      const weightDelta = b.weight - a.weight;
      if (Math.abs(weightDelta) > 5) return weightDelta;
      const aBase = getItemDims(a);
      const bBase = getItemDims(b);
      const aVolume = aBase.x * aBase.y * aBase.z;
      const bVolume = bBase.x * bBase.y * bBase.z;
      if (bVolume !== aVolume) return bVolume - aVolume;
      return bOrientation.dims.z - aOrientation.dims.z;
    });

    const newPallets = [];
    
    // Effective dimensions (after safety gap)
    const effWidth = config.palletWidth - (config.safetyGap * 2);
    const effLength = config.palletLength - (config.safetyGap * 2);

    while (sortedQueue.length > 0) {
      const pallet = {
        id: newPallets.length + 1,
        items: [],
        woodFrames: [],
        totalWeight: 0,
        currentHeight: 0,
        woodUsage: 0,
        voxelGrid: createPalletVoxelGrid()
      };
      const frameRegistry = new Set();

      // Current vertical placement height and layer tracking
      let layerY = config.lumberThick; // Start on top of bottom runners
      let maxHeightUsed = layerY;
      let palletActive = true;
      pallet.verticalZoneDepth = 0;

      // Add Pallet Base Runners (Foundation)
      // 3 long runners for the pallet base
      [0.2, 0.5, 0.8].forEach(factor => {
           addWoodFrame(
             pallet,
             createLumber(
               'base-runner',
               config.lumberWidth,
               config.lumberThick,
               config.palletLength,
               config.palletWidth * factor,
               config.lumberThick / 2,
               config.palletLength / 2
             ),
             frameRegistry
           );
      });

      while (palletActive) {
        // Track row composition and footprint for this layer
        const rowItems = [];
        let rowWidthUsed = 0;
        let rowMaxHeight = 0;
        let rowMaxLength = 0;
        let isVerticalRow = false;
        const fillOrder = sortedQueue
          .map((item, index) => ({ item, index }))
          .filter(({ item }) => !item.isPlaced)
          .sort((a, b) => {
            const aOrientation = getPreferredOrientation(a.item);
            const bOrientation = getPreferredOrientation(b.item);
            const aLength = aOrientation.vertical ? 0 : aOrientation.dims.z;
            const bLength = bOrientation.vertical ? 0 : bOrientation.dims.z;
            if (aLength !== bLength) return bLength - aLength;
            const weightDelta = b.item.weight - a.item.weight;
            if (Math.abs(weightDelta) > 5) return weightDelta;
            const aBase = getItemDims(a.item);
            const bBase = getItemDims(b.item);
            const aVolume = aBase.x * aBase.y * aBase.z;
            const bVolume = bBase.x * bBase.y * bBase.z;
            if (bVolume !== aVolume) return bVolume - aVolume;
            return bOrientation.dims.z - aOrientation.dims.z;
          });

        // Try to fill a row with items from the sorted queue
        for (const candidate of fillOrder) {
          const item = candidate.item;
          const i = candidate.index;
          if (item.isPlaced) continue;
          
          // WEIGHT CHECK
          if (pallet.totalWeight + item.weight > config.maxWeight) continue;

          // Determine Orientation
          const orientation = getPreferredOrientation(item);
          let dims = orientation.dims;
          let vertical = orientation.vertical;

          // VERTICAL CONSTRAINT: Must be on base layer
          // If we have moved up from the base layer (layerY > config.lumberThick), verticals are forbidden
          if (vertical && layerY > config.lumberThick) continue;

          if (rowItems.length > 0 && isVerticalRow !== vertical) continue;
          if (rowItems.length === 0) isVerticalRow = vertical;

          // Width Calculation with Framing
          let itemFootprintWidth = dims.x;
          if (!vertical) {
              const postW = config.lumberWidth;
              if (rowItems.length === 0) itemFootprintWidth += (postW * 2);
              else itemFootprintWidth += postW;
          } else {
              itemFootprintWidth += 0.5; // Small buffer
          }

          // Enforce space for the vertical zone at the back of the pallet
          const reservedDepth = pallet.verticalZoneDepth || 0;
          const usableLength = effLength - reservedDepth;
          if (!vertical && dims.z > usableLength) continue; 
          if (layerY + dims.y > config.maxHeight) continue;
          if (rowWidthUsed + itemFootprintWidth > effWidth) continue;

          rowItems.push({ index: i, ...item, dims, vertical });
          rowWidthUsed += itemFootprintWidth;
          rowMaxHeight = Math.max(rowMaxHeight, dims.y);
          rowMaxLength = Math.max(rowMaxLength, dims.z);
          
          // Mark as placed and update weight immediately
          item.isPlaced = true; 
          pallet.totalWeight += item.weight;
        }

        if (rowItems.length === 0) {
          palletActive = false;
        } else {
          // PLACE ROW
          const startX = (config.palletWidth - rowWidthUsed) / 2;
          const reservedDepth = pallet.verticalZoneDepth || 0;
          const frontZoneStart = config.safetyGap;
          const frontZoneEnd = config.palletLength - reservedDepth - config.safetyGap;
          const frontZoneCenter = (frontZoneStart + frontZoneEnd) / 2;
          let currentX = startX;

          let placementFailed = false;
          for (const ri of rowItems) {
            let itemX = currentX;
            if (!ri.vertical) {
                itemX += config.lumberWidth; 
            }

            const posX = itemX + (ri.dims.x / 2);
            const posY = layerY + (ri.dims.y / 2);
            const posZ = ri.vertical
              ? config.palletLength - config.safetyGap - (ri.dims.z / 2)
              : frontZoneCenter; 
            const rotationYDegrees = 0;
            const rotationYRadians = THREE.MathUtils.degToRad(rotationYDegrees);
            const voxelGrid = getItemVoxelGrid(ri, rotationYDegrees, ri.vertical);
            const fits = testVoxelFit(voxelGrid, pallet.voxelGrid, { x: posX, y: posY, z: posZ }, ri.dims);
            if (!fits) {
              reportErrors([`No placement possible for ${ri.itemNumber}. Check STL collision or pallet limits.`]);
              placementFailed = true;
              break;
            }

            pallet.items.push({
              ...sortedQueue[ri.index],
              position: { x: posX, y: posY, z: posZ },
              rotation: { x: 0, y: rotationYRadians, z: 0 },
              finalDims: ri.dims,
              vertical: ri.vertical
            });
            stampVoxels(voxelGrid, pallet.voxelGrid, { x: posX, y: posY, z: posZ }, ri.dims);

            // GENERATE FRAMING (Pockets)
            if (!ri.vertical) {
                const frameLen = ri.dims.z; 
                const pocketHeight = ri.dims.y + config.lumberThick;
                const baseHorizontalY = layerY - (config.lumberThick / 2);
                
                const zStartGlobal = posZ - (frameLen / 2);
                const leftPostX = itemX - (config.lumberWidth / 2);
                const rightPostX = itemX + ri.dims.x + (config.lumberWidth / 2);

                // Iterate Z-axis for cradle points (every framing spacing)
                for (let z = 0; z <= frameLen; z += config.framingSpacing) {
                    const zPos = zStartGlobal + z;
                    
                    // 1. Left Vertical Post
                    addWoodFrame(
                      pallet,
                      createLumber(
                        'post',
                        config.lumberWidth,
                        pocketHeight,
                        config.lumberWidth,
                        leftPostX,
                        baseHorizontalY + pocketHeight / 2,
                        zPos
                      ),
                      frameRegistry
                    );
                    
                    // 2. Right Vertical Post
                    addWoodFrame(
                      pallet,
                      createLumber(
                        'post',
                        config.lumberWidth,
                        pocketHeight,
                        config.lumberWidth,
                        rightPostX,
                        baseHorizontalY + pocketHeight / 2,
                        zPos
                      ),
                      frameRegistry
                    );
                
                // 3. Base Cross Beam (Rung) - Starts on pallet
                const rungWidth = (rightPostX - leftPostX) + config.lumberWidth;
                addWoodFrame(
                  pallet,
                  createLumber(
                    'rung',
                    rungWidth,
                    config.lumberThick,
                    config.lumberWidth,
                    (leftPostX + rightPostX) / 2,
                    baseHorizontalY,
                    zPos
                  ),
                  frameRegistry
                );

                    // 4. Diagonal Bracing (Optional)
                    if (config.addBracing && z + config.framingSpacing <= frameLen) {
                         const nextZ = zStartGlobal + z + config.framingSpacing;
                         
                         // Left Wall Diagonal
                         addWoodFrame(
                           pallet,
                           {
                             type: 'diagonal',
                             isDiagonal: true,
                             start: { x: leftPostX, y: baseHorizontalY, z: zPos },
                             end: { x: leftPostX, y: baseHorizontalY + pocketHeight, z: nextZ },
                             dims: { x: config.lumberWidth, y: config.lumberThick } 
                           },
                           frameRegistry
                         );

                         // Right Wall Diagonal
                         addWoodFrame(
                           pallet,
                           {
                             type: 'diagonal',
                             isDiagonal: true,
                             start: { x: rightPostX, y: baseHorizontalY, z: zPos },
                             end: { x: rightPostX, y: baseHorizontalY + pocketHeight, z: nextZ },
                             dims: { x: config.lumberWidth, y: config.lumberThick } 
                           },
                           frameRegistry
                         );
                    }
                }
                
                // 5. Longitudinal Side Rails (Base)
                // Left Rail
                addWoodFrame(
                  pallet,
                  createLumber(
                    'rail',
                    config.lumberWidth,
                    config.lumberThick,
                    frameLen,
                    leftPostX,
                    baseHorizontalY,
                    posZ
                  ),
                  frameRegistry
                );
                // Right Rail
                addWoodFrame(
                  pallet,
                  createLumber(
                    'rail',
                    config.lumberWidth,
                    config.lumberThick,
                    frameLen,
                    rightPostX,
                    baseHorizontalY,
                    posZ
                  ),
                  frameRegistry
                );
            }

            if (!ri.vertical) {
                currentX += ri.dims.x + config.lumberWidth; 
            } else {
                currentX += ri.dims.x + 0.5;
            }
          }
          if (placementFailed) return;

          // Update layer height depending on row type
          if (isVerticalRow) {
              pallet.verticalZoneDepth = Math.max(
                pallet.verticalZoneDepth,
                rowMaxLength + config.lumberWidth + config.safetyGap
              );
              maxHeightUsed = Math.max(maxHeightUsed, layerY + rowMaxHeight);
          } else {
              layerY += rowMaxHeight + (config.lumberThick * 2); // Space for bottom dunnage + top rung
              maxHeightUsed = Math.max(maxHeightUsed, layerY);
          }
          
          pallet.currentHeight = maxHeightUsed;
        }
      }

      // Calculate Wood Usage (linear feet approximation)
      let totalVol = 0;
      pallet.woodFrames.forEach(L => {
          if (L.isDiagonal) {
              const dx = L.end.x - L.start.x;
              const dy = L.end.y - L.start.y;
              const dz = L.end.z - L.start.z;
              totalVol += Math.sqrt(dx*dx + dy*dy + dz*dz);
          } else {
              totalVol += Math.max(L.dims.x, L.dims.y, L.dims.z);
          }
      });
      pallet.woodUsage = (totalVol / 12).toFixed(1);

      // Validate if at least one item could be placed
      const remaining = sortedQueue.filter(i => !i.isPlaced);
      if (remaining.length === sortedQueue.length) {
        reportErrors(["Item fits failed. Check max dimensions."]);
        break;
      }

      newPallets.push(pallet);
      let nextQueue = [];
      for(let i=0; i<sortedQueue.length; i++) {
        if(!sortedQueue[i].isPlaced) nextQueue.push(sortedQueue[i]);
      }
      pallet.deadzoneBox = computeDeadzoneBox(pallet);
      if (pallet.deadzoneBox) {
        addDebugLog(`Deadzone box computed (${pallet.deadzoneBox.label}) with volume ${pallet.deadzoneBox.volume.toFixed(1)} in³.`, 'info');
      }
      sortedQueue.length = 0;
      sortedQueue.push(...nextQueue);
      if (sortedQueue.length === 0) break;
    }

    // Commit results to state
    setPallets(newPallets);
    setPalletVoxelGrid(newPallets.map(p => p.voxelGrid));
    if(newPallets.length > 0) setCurrentPalletView(0);
  };

  useEffect(() => {
    if (!lastRunConfig) return;
    const configChanged = JSON.stringify(config) !== JSON.stringify(lastRunConfig);
    setIsConfigDirty(configChanged);
  }, [config, lastRunConfig]);

  const missingStlSet = new Set(stlLoadStatus.missing);

  // -------------------------------------------------------------------------
  // 4. THREE.JS RENDERING
  // -------------------------------------------------------------------------

  // Render the pallet scene every time the pallet data or view changes
  useEffect(() => {
    if (pallets.length === 0) return;
    const pallet = pallets[currentPalletView];
    const width = mountRef.current.clientWidth;
    const height = mountRef.current.clientHeight;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf3f4f6);
    sceneRef.current = scene;

    // Camera and renderer setup
    const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 2000);
    camera.position.set(config.palletWidth * 2.5, config.palletLength * 0.6, config.palletLength * 1.2);
    camera.lookAt(config.palletWidth / 2, 40, config.palletLength / 2);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    mountRef.current.innerHTML = '';
    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // Lighting for readability
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(100, 200, 100);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Pallet Base
    const baseGeo = new THREE.BoxGeometry(config.palletWidth, 5, config.palletLength);
    const baseMat = new THREE.MeshStandardMaterial({ color: 0x8D6E63 });
    const baseMesh = new THREE.Mesh(baseGeo, baseMat);
    baseMesh.position.set(config.palletWidth / 2, -2.5, config.palletLength / 2);
    baseMesh.receiveShadow = true;
    scene.add(baseMesh);

    // Render Items
    pallet.items.forEach((item) => {
      const dims = item.finalDims;
      const stlData = loadedMeshes[item.stlKey];
      const shouldRenderStl = renderStlMeshes && !renderProxyBoxes && stlData;
      const shouldRenderBox = renderProxyBoxes || !shouldRenderStl;

      if (shouldRenderStl) {
        const stlMat = new THREE.MeshStandardMaterial({
          color: colorPalette[item.colorIndex],
          roughness: 0.6,
          metalness: 0.1
        });
        const stlMesh = new THREE.Mesh(stlData.geometry.clone(), stlMat);
        if (normalizeStlToBOM && stlData.dims) {
          const scaleX = stlData.dims.x ? dims.x / stlData.dims.x : 1;
          const scaleY = stlData.dims.y ? dims.y / stlData.dims.y : 1;
          const scaleZ = stlData.dims.z ? dims.z / stlData.dims.z : 1;
          stlMesh.scale.set(scaleX, scaleY, scaleZ);
        }
        stlMesh.position.set(item.position.x, item.position.y, item.position.z);
        const verticalRotation = item.vertical ? -Math.PI / 2 : 0;
        stlMesh.rotation.set(verticalRotation, item.rotation.y, 0);
        stlMesh.castShadow = true;
        stlMesh.receiveShadow = true;
        stlMesh.userData = { item };
        scene.add(stlMesh);
      }

      if (showStlBounds) {
        const boundsGeo = new THREE.BoxGeometry(dims.x, dims.y, dims.z);
        const boundsEdges = new THREE.EdgesGeometry(boundsGeo);
        const boundsMat = new THREE.LineBasicMaterial({ color: 0x111827, opacity: 0.5, transparent: true });
        const boundsLine = new THREE.LineSegments(boundsEdges, boundsMat);
        boundsLine.position.set(item.position.x, item.position.y, item.position.z);
        scene.add(boundsLine);
      }

      if (shouldRenderBox) {
        const geo = new THREE.BoxGeometry(dims.x, dims.y, dims.z);
        const mat = new THREE.MeshStandardMaterial({
          color: colorPalette[item.colorIndex],
          roughness: 0.7,
          metalness: 0.1
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(item.position.x, item.position.y, item.position.z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData = { item };
        scene.add(mesh);

        const edges = new THREE.EdgesGeometry(geo);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.2, transparent: true }));
        line.position.copy(mesh.position);
        scene.add(line);
      }

      if (showPlacementBoxes) {
        const boxGeo = new THREE.BoxGeometry(dims.x, dims.y, dims.z);
        const boxMat = new THREE.MeshBasicMaterial({ color: 0x22d3ee, transparent: true, opacity: 0.15 });
        const boxMesh = new THREE.Mesh(boxGeo, boxMat);
        boxMesh.position.set(item.position.x, item.position.y, item.position.z);
        scene.add(boxMesh);
      }

      if (showVoxelDebug && stlData) {
        const debugGrid = getItemVoxelGrid(item, item.rotation.y * (180 / Math.PI), item.vertical);
        const maxInstances = Math.min(debugGrid.occupied.length, 5000);
        const cubeGeo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
        const cubeMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.35 });
        const instanced = new THREE.InstancedMesh(cubeGeo, cubeMat, maxInstances);
        const baseX = item.position.x - dims.x / 2;
        const baseY = item.position.y - dims.y / 2;
        const baseZ = item.position.z - dims.z / 2;
        for (let i = 0; i < maxInstances; i++) {
          const idx = debugGrid.occupied[i];
          const z = Math.floor(idx / (debugGrid.nx * debugGrid.ny));
          const y = Math.floor((idx - z * debugGrid.nx * debugGrid.ny) / debugGrid.nx);
          const x = idx - z * debugGrid.nx * debugGrid.ny - y * debugGrid.nx;
          const matrix = new THREE.Matrix4();
          matrix.setPosition(
            baseX + (x + 0.5) * voxelSize,
            baseY + (y + 0.5) * voxelSize,
            baseZ + (z + 0.5) * voxelSize
          );
          instanced.setMatrixAt(i, matrix);
        }
        scene.add(instanced);
      }
    });

    if (showDeadzoneBox && pallet.deadzoneBox) {
      const dz = pallet.deadzoneBox;
      const dzGeo = new THREE.BoxGeometry(dz.dims.x, dz.dims.y, dz.dims.z);
      const dzMat = new THREE.MeshBasicMaterial({ color: 0xa855f7, transparent: true, opacity: 0.08 });
      const dzMesh = new THREE.Mesh(dzGeo, dzMat);
      dzMesh.position.set(dz.pos.x, dz.pos.y, dz.pos.z);
      scene.add(dzMesh);
      const dzEdges = new THREE.EdgesGeometry(dzGeo);
      const dzLine = new THREE.LineSegments(dzEdges, new THREE.LineBasicMaterial({ color: 0x7e22ce, opacity: 0.5, transparent: true }));
      dzLine.position.copy(dzMesh.position);
      scene.add(dzLine);
    }

    // Render Wood Framing
    const woodMat = new THREE.MeshStandardMaterial({ color: 0xEECFA1, roughness: 0.9 });
    
    pallet.woodFrames.forEach(wf => {
        if (wf.isDiagonal) {
            const start = new THREE.Vector3(wf.start.x, wf.start.y, wf.start.z);
            const end = new THREE.Vector3(wf.end.x, wf.end.y, wf.end.z);
            const distance = start.distanceTo(end);
            const geo = new THREE.BoxGeometry(wf.dims.x, wf.dims.y, distance);
            const mesh = new THREE.Mesh(geo, woodMat);
            const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            mesh.position.copy(mid);
            mesh.lookAt(end);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
        } else {
            const geo = new THREE.BoxGeometry(wf.dims.x, wf.dims.y, wf.dims.z);
            const mesh = new THREE.Mesh(geo, woodMat);
            mesh.position.set(wf.pos.x, wf.pos.y, wf.pos.z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
        }
    });

    // Simple mouse drag orbit controls
    let isDragging = false;
    let prevPos = { x: 0, y: 0 };
    const target = new THREE.Vector3(config.palletWidth/2, config.maxHeight/3, config.palletLength/2);

    const onMouseDown = (e) => { isDragging = true; prevPos = { x: e.clientX, y: e.clientY }; };
    const onMouseUp = () => { isDragging = false; };
    const onMouseMove = (e) => {
        if (!isDragging) return;
        const dx = e.clientX - prevPos.x;
        const dy = e.clientY - prevPos.y;
        prevPos = { x: e.clientX, y: e.clientY };
        const offset = new THREE.Vector3().subVectors(camera.position, target);
        const theta = Math.atan2(offset.x, offset.z);
        const phi = Math.atan2(Math.sqrt(offset.x*offset.x + offset.z*offset.z), offset.y);
        const newTheta = theta - dx * 0.01;
        const newPhi = Math.max(0.1, Math.min(Math.PI - 0.1, phi - dy * 0.01));
        const radius = offset.length();
        camera.position.x = target.x + radius * Math.sin(newPhi) * Math.sin(newTheta);
        camera.position.y = target.y + radius * Math.cos(newPhi);
        camera.position.z = target.z + radius * Math.sin(newPhi) * Math.cos(newTheta);
        camera.lookAt(target);
    };

    renderer.domElement.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mouseup', onMouseUp);
    window.addEventListener('mousemove', onMouseMove);

    // Render loop
    const animate = () => {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    };
    animate();

    return () => {
        renderer.domElement.removeEventListener('mousedown', onMouseDown);
        window.removeEventListener('mouseup', onMouseUp);
        window.removeEventListener('mousemove', onMouseMove);
    };
  }, [
    pallets,
    currentPalletView,
    config,
    loadedMeshes,
    renderStlMeshes,
    renderProxyBoxes,
    showPlacementBoxes,
    showVoxelDebug,
    showStlBounds,
    showDeadzoneBox
  ]);

  return (
    <div className="flex flex-col h-screen bg-gray-50 text-gray-800 font-sans">
      <header className="bg-white border-b px-6 py-4 flex justify-between items-center shadow-sm">
        <div className="flex items-center gap-3">
            <div className="bg-orange-600 p-2 rounded-lg text-white"><Hammer size={24} /></div>
            <div>
                <h1 className="text-xl font-bold text-gray-900">Structural Crate Optimizer</h1>
                <p className="text-xs text-gray-500">Auto-framing, wood calculation, and pipe stacking</p>
            </div>
        </div>
        <div className="flex gap-3">
             <button onClick={loadDemoData} className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-purple-700 bg-purple-50 hover:bg-purple-100 rounded-md border border-purple-200 transition-colors">
                <Zap size={16} /> Load Demo
            </button>
            <button onClick={runOptimization} disabled={items.length===0} className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-md shadow-sm transition-colors disabled:opacity-50">
                <Play size={16} /> Build Crate
            </button>
            {isConfigDirty && (
              <button onClick={runOptimization} disabled={items.length===0} className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-amber-900 bg-amber-200 hover:bg-amber-300 rounded-md border border-amber-300 shadow-sm transition-colors disabled:opacity-50">
                  <RefreshCw size={16} /> Refresh Preview
              </button>
            )}
        </div>
      </header>

      <main className="flex-1 flex overflow-hidden">
        <div className="w-80 bg-white border-r flex flex-col">
            <div className="p-2 border-b bg-gray-50 flex gap-2 text-xs font-semibold">
                <button
                  onClick={() => setSidebarTab('controls')}
                  className={`flex-1 px-3 py-1 rounded ${sidebarTab === 'controls' ? 'bg-white border text-gray-800 shadow-sm' : 'text-gray-500 hover:text-gray-700'}`}
                >
                  Controls
                </button>
                <button
                  onClick={() => setSidebarTab('terminal')}
                  className={`flex-1 px-3 py-1 rounded ${sidebarTab === 'terminal' ? 'bg-white border text-gray-800 shadow-sm' : 'text-gray-500 hover:text-gray-700'}`}
                >
                  Terminal
                </button>
            </div>
            {sidebarTab === 'controls' ? (
            <div className="flex-1 flex flex-col overflow-y-auto">
            {/* CONFIG */}
            <div className="p-4 border-b space-y-4">
                <h2 className="text-xs font-bold text-gray-400 uppercase tracking-wider flex items-center gap-2"><Settings size={12}/> Pallet Configuration</h2>
                
                <div className="grid grid-cols-2 gap-3">
                    <div>
                        <label className="text-xs font-medium text-gray-600">Pallet Len (in)</label>
                        <input type="number" value={config.palletLength} onChange={e => setConfig({...config, palletLength: Number(e.target.value)})} className="w-full mt-1 px-2 py-1 text-sm border rounded focus:ring-2 focus:ring-blue-500 outline-none" />
                    </div>
                    <div>
                        <label className="text-xs font-medium text-gray-600">Pallet Wid (in)</label>
                        <input type="number" value={config.palletWidth} onChange={e => setConfig({...config, palletWidth: Number(e.target.value)})} className="w-full mt-1 px-2 py-1 text-sm border rounded focus:ring-2 focus:ring-blue-500 outline-none" />
                    </div>
                </div>

                <div className="grid grid-cols-2 gap-3">
                    <div>
                        <label className="text-xs font-medium text-gray-600 flex items-center gap-1"><ArrowUp size={10}/> Max Height</label>
                        <input type="number" value={config.maxHeight} onChange={e => setConfig({...config, maxHeight: Number(e.target.value)})} className="w-full mt-1 px-2 py-1 text-sm border rounded focus:ring-2 focus:ring-blue-500 outline-none" />
                    </div>
                    <div>
                        <label className="text-xs font-medium text-gray-600 flex items-center gap-1"><Scale size={10}/> Max Lbs</label>
                        <input type="number" value={config.maxWeight} onChange={e => setConfig({...config, maxWeight: Number(e.target.value)})} className="w-full mt-1 px-2 py-1 text-sm border rounded focus:ring-2 focus:ring-blue-500 outline-none" />
                    </div>
                </div>

                <div className="grid grid-cols-2 gap-3">
                    <div>
                         <label className="text-xs font-medium text-gray-600 flex items-center gap-1"><ShieldAlert size={10}/> Safety Gap</label>
                         <input type="number" step="0.5" value={config.safetyGap} onChange={e => setConfig({...config, safetyGap: Number(e.target.value)})} className="w-full mt-1 px-2 py-1 text-sm border rounded focus:ring-2 focus:ring-blue-500 outline-none" />
                    </div>
                    <div>
                        <label className="text-xs font-medium text-gray-600">Post Spacing</label>
                        <input type="number" value={config.framingSpacing} onChange={e => setConfig({...config, framingSpacing: Number(e.target.value)})} className="w-full mt-1 px-2 py-1 text-sm border rounded focus:ring-2 focus:ring-blue-500 outline-none" />
                    </div>
                </div>

                <div>
                    <label className="text-xs font-medium text-gray-600 flex items-center gap-1">Diagonal Bracing</label>
                    <select 
                        value={config.addBracing} 
                        onChange={e => setConfig({...config, addBracing: e.target.value === 'true'})}
                        className="w-full mt-1 px-2 py-1 text-sm border rounded focus:ring-2 focus:ring-blue-500 outline-none"
                    >
                        <option value="true">Yes - Add Structural Cross-Bracing</option>
                        <option value="false">No - Vertical Posts Only</option>
                    </select>
                </div>
                <div>
                    <label className="text-xs font-medium text-gray-600 flex items-center gap-1">Vertical Stacking</label>
                    <select 
                        value={config.allowVertical} 
                        onChange={e => setConfig({...config, allowVertical: e.target.value === 'true'})}
                        className="w-full mt-1 px-2 py-1 text-sm border rounded focus:ring-2 focus:ring-blue-500 outline-none"
                    >
                        <option value="true">Auto - Stand Short Items</option>
                        <option value="false">No - Always Lay Flat</option>
                    </select>
                </div>
                {isConfigDirty && (
                  <div className="rounded-md border border-amber-200 bg-amber-50 px-3 py-2 text-[11px] text-amber-900">
                    Config changed. Click Refresh Preview to recalculate the stack.
                  </div>
                )}
            </div>

            {/* STL INPUT */}
            <div className="p-4 border-b bg-gray-50 space-y-3">
                <h2 className="text-xs font-bold text-gray-400 uppercase tracking-wider">STL Input</h2>
                <label className="flex flex-col items-center justify-center w-full h-20 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-white hover:bg-gray-50 transition-colors">
                    <div className="flex flex-col items-center justify-center pt-2 pb-2">
                        <Upload size={20} className="text-gray-400 mb-1" />
                        <p className="text-[10px] text-gray-500">Select STL Folder</p>
                    </div>
                    <input type="file" className="hidden" accept=".stl" multiple webkitdirectory="true" directory="true" onChange={loadSTLFolder} />
                </label>
                <div className="text-[10px] text-gray-500">
                    {stlFilesAvailable
                      ? `Loaded ${stlLoadStatus.loaded} / ${stlLoadStatus.total} queued STLs`
                      : 'No STL folder selected (CSV-only mode).'}
                </div>
                <label className="flex items-center gap-2 text-xs text-gray-600">
                  <input
                    type="checkbox"
                    checked={useStlForCollisions}
                    onChange={e => setUseStlForCollisions(e.target.checked)}
                  />
                  Use STL geometry for collision checks (slower)
                </label>
                {stlFilesAvailable && stlLoadStatus.missing.length > 0 && (
                  <div className="text-[10px] text-amber-700">
                    Missing: {stlLoadStatus.missing.join(', ')}
                  </div>
                )}
            </div>

            {/* BOM UPLOAD */}
            <div className="p-4 border-b bg-white space-y-3">
                <h2 className="text-xs font-bold text-gray-400 uppercase tracking-wider">BOM Upload</h2>
                <label className="flex flex-col items-center justify-center w-full h-20 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-white hover:bg-gray-50 transition-colors">
                    <div className="flex flex-col items-center justify-center pt-2 pb-2">
                        <Upload size={20} className="text-gray-400 mb-1" />
                        <p className="text-[10px] text-gray-500">Upload CSV (number, weight, qty; H/W/L optional if STL provided)</p>
                    </div>
                    <input type="file" className="hidden" accept=".csv" onChange={handleFileUpload} />
                </label>
                {bomItems.length > 0 && (
                  <div className="space-y-1 text-[10px] text-gray-600">
                    {bomItems.map((item, idx) => {
                      const csvDimsOk = hasValidCsvDims(item);
                      const stlMissing = stlFilesAvailable && (missingStlSet.has(item.stlKey) || !item.stlFound);
                      let statusText = 'CSV dims';
                      let statusClass = 'bg-slate-100 text-slate-600';
                      if (!csvDimsOk) {
                        statusText = stlMissing ? 'Missing STL' : 'STL required';
                        statusClass = stlMissing ? 'bg-amber-100 text-amber-700' : 'bg-emerald-100 text-emerald-700';
                      } else if (stlFilesAvailable && item.stlFound && shouldUseStlGeometry) {
                        statusText = 'STL ready';
                        statusClass = 'bg-emerald-100 text-emerald-700';
                      }
                      return (
                        <div key={idx} className="flex justify-between items-center bg-gray-50 border rounded px-2 py-1">
                          <span>{item.itemNumber}</span>
                          <span className="text-gray-400">x{item.qty}</span>
                          <span className={`px-2 py-0.5 rounded ${statusClass}`}>
                            {statusText}
                          </span>
                        </div>
                      );
                    })}
                  </div>
                )}
            </div>

            {/* UNITS */}
            <div className="p-4 border-b bg-gray-50 space-y-2">
                <h2 className="text-xs font-bold text-gray-400 uppercase tracking-wider">Units</h2>
                <label className="text-xs font-medium text-gray-600">STL Units</label>
                <select
                  value={stlUnits}
                  onChange={e => setStlUnits(e.target.value)}
                  className="w-full mt-1 px-2 py-1 text-sm border rounded focus:ring-2 focus:ring-blue-500 outline-none"
                >
                  <option value="in">inches</option>
                  <option value="mm">mm</option>
                </select>
                <label className="flex items-start gap-2 text-xs text-gray-600">
                  <input
                    type="checkbox"
                    className="mt-0.5"
                    checked={normalizeStlToBOM}
                    onChange={e => setNormalizeStlToBOM(e.target.checked)}
                  />
                  <span>Override STL dimensions with CSV values (debug only).</span>
                </label>
            </div>

            {/* DISPLAY */}
            <div className="p-4 border-b bg-white space-y-2">
                <h2 className="text-xs font-bold text-gray-400 uppercase tracking-wider">Display</h2>
                <label className="flex items-center gap-2 text-xs text-gray-600">
                  <input type="checkbox" checked={renderStlMeshes} onChange={e => setRenderStlMeshes(e.target.checked)} />
                  Render STL meshes (loads geometry)
                </label>
                <label className="flex items-center gap-2 text-xs text-gray-600">
                  <input type="checkbox" checked={renderProxyBoxes} onChange={e => setRenderProxyBoxes(e.target.checked)} />
                  Render proxy boxes only
                </label>
                <label className="flex items-center gap-2 text-xs text-gray-600">
                  <input type="checkbox" checked={showStlBounds} onChange={e => setShowStlBounds(e.target.checked)} />
                  Show STL bounding boxes
                </label>
                <label className="flex items-center gap-2 text-xs text-gray-600">
                  <input type="checkbox" checked={showPlacementBoxes} onChange={e => setShowPlacementBoxes(e.target.checked)} />
                  Show placement boxes
                </label>
                <label className="flex items-center gap-2 text-xs text-gray-600">
                  <input type="checkbox" checked={showDeadzoneBox} onChange={e => setShowDeadzoneBox(e.target.checked)} />
                  Show deadzone box (largest open volume)
                </label>
                <label className="flex items-center gap-2 text-xs text-gray-600">
                  <input type="checkbox" checked={showVoxelDebug} onChange={e => setShowVoxelDebug(e.target.checked)} />
                  Debug: show voxel cubes
                </label>
            </div>

            {/* ERROR */}
            {errors.length > 0 && (
                <div className="p-4 bg-red-50 border-b border-red-100">
                    <div className="text-xs text-red-600 font-medium mb-1">Errors</div>
                    <ul className="list-disc list-inside text-[10px] text-red-500">
                        {errors.map((e,i) => <li key={i}>{e}</li>)}
                    </ul>
                </div>
            )}

            {/* ITEMS */}
            <div className="flex-1 p-4 overflow-y-auto">
                <h2 className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2">Manifest</h2>
                <div className="space-y-2">
                    {Array.from(new Set(items.map(i => i.itemNumber))).map((num, i) => {
                        const group = items.filter(x => x.itemNumber === num);
                        return (
                            <div key={i} className="bg-white border rounded p-2 text-xs shadow-sm flex justify-between items-center">
                                <span className="font-bold">{num}</span>
                                <span className="bg-gray-100 px-2 py-0.5 rounded text-gray-500">x{group.length}</span>
                            </div>
                        )
                    })}
                </div>
            </div>
            </div>
            ) : (
            <div className="flex-1 flex flex-col bg-slate-900 text-slate-100">
                <div className="p-3 border-b border-slate-800 flex items-center justify-between">
                    <div className="text-xs font-bold uppercase tracking-wider text-slate-300">Debug Terminal</div>
                    <button
                      onClick={() => setDebugLogs([])}
                      className="text-[10px] text-slate-400 hover:text-slate-200"
                    >
                      Clear
                    </button>
                </div>
                <div className="flex-1 overflow-y-auto px-3 py-2 font-mono text-[10px] space-y-1">
                    {debugLogs.length === 0 ? (
                      <div className="text-slate-500">No debug messages yet.</div>
                    ) : (
                      debugLogs.map(log => {
                        const levelClass = log.level === 'error'
                          ? 'text-red-300'
                          : log.level === 'warn'
                            ? 'text-amber-300'
                            : 'text-slate-200';
                        return (
                          <div key={log.id} className="flex gap-2">
                            <span className="text-slate-500">{log.timestamp}</span>
                            <span className={`uppercase ${levelClass}`}>{log.level}</span>
                            <span className={levelClass}>{log.message}</span>
                          </div>
                        );
                      })
                    )}
                </div>
            </div>
            )}
        </div>

        {/* CANVAS */}
        <div className="flex-1 flex flex-col bg-gray-200 relative">
            <div ref={mountRef} className="flex-1 w-full h-full cursor-move" />

            {/* PALLET CONTROLS */}
            {pallets.length > 0 && (
                <div className="absolute bottom-6 left-1/2 -translate-x-1/2 bg-white rounded-full shadow-lg border px-6 py-3 flex items-center gap-6">
                    <button 
                        onClick={() => setCurrentPalletView(Math.max(0, currentPalletView - 1))}
                        disabled={currentPalletView===0}
                        className="text-gray-500 hover:text-blue-600 disabled:opacity-30"
                    >
                        Prev
                    </button>
                    <div className="text-sm font-bold text-gray-800">
                        Crate {currentPalletView + 1} <span className="text-gray-400 font-normal">of {pallets.length}</span>
                    </div>
                    <button 
                        onClick={() => setCurrentPalletView(Math.min(pallets.length-1, currentPalletView + 1))}
                        disabled={currentPalletView===pallets.length-1}
                        className="text-gray-500 hover:text-blue-600 disabled:opacity-30"
                    >
                        Next
                    </button>
                </div>
            )}
            
            {/* STATS PANEL */}
            {pallets.length > 0 && (
                <div className="absolute top-4 right-4 bg-white/95 backdrop-blur rounded-lg shadow-md border p-4 w-64">
                    <h3 className="text-xs font-bold text-gray-400 uppercase mb-3 border-b pb-1">Bill of Materials</h3>
                    <div className="space-y-3 text-sm">
                        <div className="flex justify-between items-center">
                            <span className="text-gray-600 flex items-center gap-2"><Scale size={14}/> Cargo Weight</span>
                            <span className={`font-mono font-bold ${pallets[currentPalletView].totalWeight > config.maxWeight ? 'text-red-600' : 'text-gray-800'}`}>
                                {pallets[currentPalletView].totalWeight} / {config.maxWeight} lbs
                            </span>
                        </div>
                        
                        <div className="flex justify-between items-center text-blue-800 bg-blue-50 p-2 rounded">
                            <span className="text-blue-600 flex items-center gap-2"><Hammer size={14}/> Wood Req.</span>
                            <div className="text-right">
                                <div className="font-mono font-bold">{pallets[currentPalletView].woodUsage} ft</div>
                                <div className="text-[10px] opacity-70">~{Math.ceil(pallets[currentPalletView].woodUsage / 8)} (8ft boards)</div>
                            </div>
                        </div>

                         <div className="flex justify-between items-center">
                            <span className="text-gray-600 flex items-center gap-2"><ArrowUp size={14}/> Total Height</span>
                            <span className="font-mono font-bold text-gray-800">{pallets[currentPalletView].currentHeight.toFixed(1)}"</span>
                        </div>
                    </div>
                </div>
            )}
        </div>
      </main>
    </div>
  );
};




        // --- MOUNT ---
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<PalletOptimizer />);
    </script>
    
    <script>
        // Initialize Tailwind config if needed
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Sora', 'sans-serif'],
                    }
                }
            }
        }
    </script>
</body>
</html>
